{"ast":null,"code":"// Тип очереди с основными операциями\n\nexport class Queue {\n  // Конструктор с указанием максимального размера очереди\n  constructor(size) {\n    // Приватные члены класса Queue для управления структурой списка\n    this.container = [];\n    this.head = 0;\n    this.tail = 0;\n    this.length = 0;\n    this.size = 0;\n    // Добавление элемента в конец очереди\n    this.enqueue = i => {\n      if (this.length >= this.size) {\n        throw new Error(\"Maximum length error\");\n      }\n      this.container[this.tail % this.size] = i;\n      this.tail++;\n      this.length++;\n    };\n    // Удаление элемента из начала очереди\n    this.dequeue = () => {\n      if (this.isEmpty()) {\n        throw new Error(\"The queue is empty\");\n      }\n      const item = this.container[this.head];\n      delete this.container[this.head % this.size];\n      this.length--;\n      this.head++;\n      return item;\n    };\n    // Получение элемента из начала очереди без удаления\n    this.peek = () => {\n      if (this.isEmpty()) {\n        throw new Error(\"The queue is empty\");\n      }\n      return this.container[this.head];\n    };\n    // Получение последнего элемента очереди без удаления\n    this.getTail = () => {\n      if (this.isEmpty()) {\n        throw new Error(\"The queue is empty\");\n      }\n      return this.container[this.tail - 1];\n    };\n    // Получение всех элементов очереди\n    this.getElements = () => {\n      return this.container;\n    };\n    // Проверка, является ли очередь пустой\n    this.isEmpty = () => this.length === 0;\n    // Очистка очереди\n    this.clear = () => {\n      this.head = 0;\n      this.tail = 0;\n      this.container = Array(this.size);\n      this.length = 0;\n    };\n    this.size = size;\n    this.container = Array(size);\n  }\n}","map":{"version":3,"names":["Queue","constructor","size","container","head","tail","length","enqueue","i","Error","dequeue","isEmpty","item","peek","getTail","getElements","clear","Array"],"sources":["/Users/illia/Documents/_2024/_learn /algo-sosh/src/components/queue-page/queue-page-algorithm.ts"],"sourcesContent":["// Тип очереди с основными операциями\ntype TQueue<T> = {\n  enqueue: (item: T) => void;\n  dequeue: () => void;\n  peek: () => T | null;\n  getTail: () => T | null;\n  getElements: () => (T | null)[];\n  isEmpty: () => boolean;\n  clear: () => void;\n};\n\nexport class Queue<T> implements TQueue<T> {\n  // Приватные члены класса Queue для управления структурой списка\n  private container: (T | null)[] = [];\n  private head = 0;\n  private tail = 0;\n  private length: number = 0;\n  private size: number = 0;\n\n  // Конструктор с указанием максимального размера очереди\n  constructor(size: number) {\n    this.size = size;\n    this.container = Array(size);\n  }\n  \n  // Добавление элемента в конец очереди\n  enqueue = (i: T) => {\n    if (this.length >= this.size) {\n      throw new Error(\"Maximum length error\");\n    }\n    this.container[this.tail % this.size] = i;\n    this.tail++;\n    this.length++;\n  };\n\n  // Удаление элемента из начала очереди\n  dequeue = () => {\n    if (this.isEmpty()) {\n      throw new Error(\"The queue is empty\");\n    }\n    const item = this.container[this.head];\n    delete this.container[this.head % this.size];\n    this.length--;\n    this.head++;\n    return item;\n  };\n\n  // Получение элемента из начала очереди без удаления\n  peek = () => {\n    if (this.isEmpty()) {\n      throw new Error(\"The queue is empty\");\n    }\n    return this.container[this.head];\n  };\n\n  // Получение последнего элемента очереди без удаления\n  getTail = () => {\n    if (this.isEmpty()) {\n      throw new Error(\"The queue is empty\");\n    }\n    return this.container[this.tail - 1];\n  };\n\n  // Получение всех элементов очереди\n  getElements = () => {\n    return this.container;\n  };\n\n  // Проверка, является ли очередь пустой\n  isEmpty = () => this.length === 0;\n  \n  // Очистка очереди\n  clear = () => {\n    this.head = 0;\n    this.tail = 0;\n    this.container = Array(this.size);\n    this.length = 0;\n  };\n}\n"],"mappings":"AAAA;;AAWA,OAAO,MAAMA,KAAK,CAAyB;EAQzC;EACAC,WAAWA,CAACC,IAAY,EAAE;IAR1B;IAAA,KACQC,SAAS,GAAiB,EAAE;IAAA,KAC5BC,IAAI,GAAG,CAAC;IAAA,KACRC,IAAI,GAAG,CAAC;IAAA,KACRC,MAAM,GAAW,CAAC;IAAA,KAClBJ,IAAI,GAAW,CAAC;IAQxB;IAAA,KACAK,OAAO,GAAIC,CAAI,IAAK;MAClB,IAAI,IAAI,CAACF,MAAM,IAAI,IAAI,CAACJ,IAAI,EAAE;QAC5B,MAAM,IAAIO,KAAK,CAAC,sBAAsB,CAAC;MACzC;MACA,IAAI,CAACN,SAAS,CAAC,IAAI,CAACE,IAAI,GAAG,IAAI,CAACH,IAAI,CAAC,GAAGM,CAAC;MACzC,IAAI,CAACH,IAAI,EAAE;MACX,IAAI,CAACC,MAAM,EAAE;IACf,CAAC;IAED;IAAA,KACAI,OAAO,GAAG,MAAM;MACd,IAAI,IAAI,CAACC,OAAO,CAAC,CAAC,EAAE;QAClB,MAAM,IAAIF,KAAK,CAAC,oBAAoB,CAAC;MACvC;MACA,MAAMG,IAAI,GAAG,IAAI,CAACT,SAAS,CAAC,IAAI,CAACC,IAAI,CAAC;MACtC,OAAO,IAAI,CAACD,SAAS,CAAC,IAAI,CAACC,IAAI,GAAG,IAAI,CAACF,IAAI,CAAC;MAC5C,IAAI,CAACI,MAAM,EAAE;MACb,IAAI,CAACF,IAAI,EAAE;MACX,OAAOQ,IAAI;IACb,CAAC;IAED;IAAA,KACAC,IAAI,GAAG,MAAM;MACX,IAAI,IAAI,CAACF,OAAO,CAAC,CAAC,EAAE;QAClB,MAAM,IAAIF,KAAK,CAAC,oBAAoB,CAAC;MACvC;MACA,OAAO,IAAI,CAACN,SAAS,CAAC,IAAI,CAACC,IAAI,CAAC;IAClC,CAAC;IAED;IAAA,KACAU,OAAO,GAAG,MAAM;MACd,IAAI,IAAI,CAACH,OAAO,CAAC,CAAC,EAAE;QAClB,MAAM,IAAIF,KAAK,CAAC,oBAAoB,CAAC;MACvC;MACA,OAAO,IAAI,CAACN,SAAS,CAAC,IAAI,CAACE,IAAI,GAAG,CAAC,CAAC;IACtC,CAAC;IAED;IAAA,KACAU,WAAW,GAAG,MAAM;MAClB,OAAO,IAAI,CAACZ,SAAS;IACvB,CAAC;IAED;IAAA,KACAQ,OAAO,GAAG,MAAM,IAAI,CAACL,MAAM,KAAK,CAAC;IAEjC;IAAA,KACAU,KAAK,GAAG,MAAM;MACZ,IAAI,CAACZ,IAAI,GAAG,CAAC;MACb,IAAI,CAACC,IAAI,GAAG,CAAC;MACb,IAAI,CAACF,SAAS,GAAGc,KAAK,CAAC,IAAI,CAACf,IAAI,CAAC;MACjC,IAAI,CAACI,MAAM,GAAG,CAAC;IACjB,CAAC;IAxDC,IAAI,CAACJ,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,SAAS,GAAGc,KAAK,CAACf,IAAI,CAAC;EAC9B;AAuDF"},"metadata":{},"sourceType":"module","externalDependencies":[]}