{"ast":null,"code":"// Класс, представляющий узел связанного списка\nexport class Node {\n  // Конструктор, инициализирующий значение узла и указатель на следующий узел\n  constructor(value, next) {\n    this.value = void 0;\n    this.next = void 0;\n    this.value = value;\n    this.next = this.next = next === undefined ? null : next;\n  }\n}\n\n// Интерфейс для связанного списка\n\n// Класс, представляющий связанный список\nexport class LinkedList {\n  // Конструктор, инициализирующий список значениями из массива\n  constructor(arr) {\n    // Приватные члены класса LinkedList для управления структурой списка\n    this.head = void 0;\n    this.tail = void 0;\n    this.size = void 0;\n    this.length = void 0;\n    this.head = null;\n    this.tail = null;\n    this.size = 0;\n    this.length = 0;\n    arr.forEach(item => this.append(item));\n  }\n  // Добавление элемента в конец списка\n  append(el) {\n    // Создаем новый узел с переданным значением\n    const node = new Node(el);\n    // Если список пустой, устанавливаем новый узел как начальный и конечный\n    if (!this.head || !this.tail) {\n      this.head = node;\n      this.tail = node;\n      return this; // Возвращаем ссылку на текущий объект для поддержки цепочки вызовов\n    }\n    // Если список не пуст, добавляем новый узел после текущего хвоста\n    this.tail.next = node;\n    // Обновляем хвост списка на новый узел\n    this.tail = node;\n    // Увеличиваем счетчик длины списка и общего размера\n    this.length++;\n    this.size++;\n    return this; // Возвращаем ссылку на текущий объект для поддержки цепочки вызовов\n  }\n  // Добавление элемента в начало списка\n  prepend(el) {\n    // Создаем новый узел с переданным значением и устанавливаем следующим элементом текущий начальный узел\n    const node = new Node(el, this.head);\n    // Обновляем начальный узел списка на новый узел\n    this.head = node;\n    // Если список пустой, устанавливаем новый узел также как конечный\n    if (!this.tail) {\n      this.tail = node;\n    }\n    // Увеличиваем счетчик\n    this.length++;\n    this.size++;\n    return this; // Возвращаем ссылку на текущий объект\n  }\n  // Удаление первого элемента списка\n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n    // Запоминаем ссылку на удаляемый начальный узел\n    const deletedHead = this.head;\n    // Если есть следующий элемент после начального, обновляем начальный узел\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      // Если начальный узел был единственным в списке, обнуляем начальный и конечный узлы\n      this.head = null;\n      this.tail = null;\n    }\n    // Уменьшаем счетчик\n    this.size--;\n    this.length--;\n    return deletedHead; // Возвращаем удаленный узел\n  }\n  // Удаление последнего элемента списка\n  deleteTail() {\n    if (!this.tail) {\n      return null;\n    }\n    const deletedTail = this.tail;\n    // Если начальный и конечный узлы совпадают, значит в списке только один элемент\n    if (this.head === this.tail) {\n      this.head = null;\n      this.tail = null;\n      return deletedTail;\n    }\n    // Ищем предпоследний узел, чтобы обновить конечный узел\n    let currentNode = this.head;\n    while ((_currentNode = currentNode) !== null && _currentNode !== void 0 && _currentNode.next) {\n      var _currentNode;\n      if (!currentNode.next.next) {\n        // Обрываем связь с последним узлом, делая предпоследний узел новым конечным\n        currentNode.next = null;\n      } else {\n        currentNode = currentNode.next;\n      }\n    }\n    // Обновляем конечный узел\n    this.tail = currentNode;\n    this.size--;\n    this.length--;\n    return deletedTail;\n  }\n  // Добавление элемента по индексу\n  addByIndex(element, index) {\n    if (index < 0 || index > this.size) {\n      return;\n    } else {\n      const node = new Node(element);\n      let el;\n      if (index === 0) {\n        node.next = this.head;\n        this.head = node;\n      } else {\n        let current = this.head;\n        let currentIndex = 0;\n        while (currentIndex++ < index) {\n          el = current;\n          if (current) {\n            current = current.next;\n          }\n        }\n        if (el) {\n          node.next = current;\n          el.next = node;\n        }\n      }\n      this.size++;\n      this.length++;\n    }\n  }\n  // Удаление элемента по индексу\n  deleteByIndex(index) {\n    // Проверяем, что индекс находится в допустимом диапазоне\n    if (index < 0 || index > this.size) {\n      return;\n    }\n    let start = this.head;\n    // Если индекс 0, добавляем новый узел в начало списка\n    if (index === 0) {\n      this.head = this.head ? this.head.next : this.head;\n    } else {\n      var _current;\n      let current = null;\n      let currIndex = 0;\n      // Ищем узел с указанным индексом\n      while (currIndex++ < index) {\n        // Запоминаем текущий узел и переходим к следующему, если есть\n        current = start;\n        if (start) {\n          start = start.next;\n        }\n      }\n      // Обрываем связь между предыдущим и удаляемым узлом\n      if ((_current = current) !== null && _current !== void 0 && _current.next) {\n        var _start;\n        current.next = (_start = start) !== null && _start !== void 0 && _start.next ? start.next : null;\n      }\n    }\n    this.size--;\n    this.length--;\n  }\n  // Преобразование списка в массив\n  toArray() {\n    // Инициализация указателя на начало списка\n    let current = this.head;\n    // Создание массива для хранения значений узлов списка\n    const array = [];\n    // Проход по списку\n    while (current) {\n      var _current2;\n      // Добавление значения текущего узла\n      array.push((_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.value);\n      // Переход к следующему узлу\n      current = current.next;\n    }\n    return array;\n  }\n  // Получение размера списка\n  getSize() {\n    return this.size;\n  }\n}","map":{"version":3,"names":["Node","constructor","value","next","undefined","LinkedList","arr","head","tail","size","length","forEach","item","append","el","node","prepend","deleteHead","deletedHead","deleteTail","deletedTail","currentNode","_currentNode","addByIndex","element","index","current","currentIndex","deleteByIndex","start","_current","currIndex","_start","toArray","array","_current2","push","getSize"],"sources":["/Users/illia/Documents/_2024/_learn /algo-sosh/src/components/list-page/list-algorithm.ts"],"sourcesContent":["// Класс, представляющий узел связанного списка\nexport class Node<T> {\n  value: T;\n  next: Node<T> | null;\n  // Конструктор, инициализирующий значение узла и указатель на следующий узел\n  constructor(value: T, next?: Node<T> | null) {\n    this.value = value;\n    this.next = this.next = next === undefined ? null : next;\n  }\n}\n\n// Интерфейс для связанного списка\ninterface ILinkedList<T> {\n  append: (element: T) => void;\n  prepend: (element: T) => this;\n  // Получение размера списка\n  getSize: () => number;\n  // Добавление элемента по индексу\n  addByIndex: (element: T, index: number) => void;\n  // Удаление элемента по индексубю\n  deleteByIndex: (index: number) => void;\n  // Удаление первого элемента списка\n  deleteHead: () => Node<T> | null;\n  // Удаление последнего элемента списка\n  deleteTail: () => Node<T> | null;\n  // Преобразование списка в массив\n  toArray: () => T[];\n}\n\n// Класс, представляющий связанный список\nexport class LinkedList<T> implements ILinkedList<T> {\n  // Приватные члены класса LinkedList для управления структурой списка\n  private head: Node<T> | null;\n  private tail: Node<T> | null;\n  private size: number;\n  private length: number;\n  // Конструктор, инициализирующий список значениями из массива\n  constructor(arr: T[]) {\n    this.head = null;\n    this.tail = null;\n    this.size = 0;\n    this.length = 0;\n    arr.forEach((item) => this.append(item));\n  }\n  // Добавление элемента в конец списка\n  append(el: T) {\n    // Создаем новый узел с переданным значением\n    const node = new Node(el);\n    // Если список пустой, устанавливаем новый узел как начальный и конечный\n    if (!this.head || !this.tail) {\n      this.head = node;\n      this.tail = node;\n      return this; // Возвращаем ссылку на текущий объект для поддержки цепочки вызовов\n    }\n    // Если список не пуст, добавляем новый узел после текущего хвоста\n    this.tail.next = node;\n    // Обновляем хвост списка на новый узел\n    this.tail = node;\n    // Увеличиваем счетчик длины списка и общего размера\n    this.length++;\n    this.size++;\n    return this; // Возвращаем ссылку на текущий объект для поддержки цепочки вызовов\n  }\n  // Добавление элемента в начало списка\n  prepend(el: T) {\n    // Создаем новый узел с переданным значением и устанавливаем следующим элементом текущий начальный узел\n    const node = new Node(el, this.head);\n    // Обновляем начальный узел списка на новый узел\n    this.head = node;\n    // Если список пустой, устанавливаем новый узел также как конечный\n    if (!this.tail) {\n      this.tail = node;\n    }\n    // Увеличиваем счетчик\n    this.length++;\n    this.size++;\n    return this; // Возвращаем ссылку на текущий объект\n  }\n  // Удаление первого элемента списка\n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n    // Запоминаем ссылку на удаляемый начальный узел\n    const deletedHead = this.head;\n    // Если есть следующий элемент после начального, обновляем начальный узел\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      // Если начальный узел был единственным в списке, обнуляем начальный и конечный узлы\n      this.head = null;\n      this.tail = null;\n    }\n    // Уменьшаем счетчик\n    this.size--;\n    this.length--;\n    return deletedHead; // Возвращаем удаленный узел\n  }\n  // Удаление последнего элемента списка\n  deleteTail() {\n    if (!this.tail) {\n      return null;\n    }\n    const deletedTail = this.tail;\n    // Если начальный и конечный узлы совпадают, значит в списке только один элемент\n    if (this.head === this.tail) {\n      this.head = null;\n      this.tail = null;\n      return deletedTail;\n    }\n    // Ищем предпоследний узел, чтобы обновить конечный узел\n    let currentNode = this.head;\n    while (currentNode?.next) {\n      if (!currentNode.next.next) {\n        // Обрываем связь с последним узлом, делая предпоследний узел новым конечным\n        currentNode.next = null;\n      } else {\n        currentNode = currentNode.next;\n      }\n    }\n    // Обновляем конечный узел\n    this.tail = currentNode;\n    this.size--;\n    this.length--;\n    return deletedTail;\n  }\n  // Добавление элемента по индексу\n  addByIndex(element: T, index: number) {\n    if (index < 0 || index > this.size) {\n      return;\n    } else {\n      const node = new Node(element);\n      let el;\n      if (index === 0) {\n        node.next = this.head;\n        this.head = node;\n      } else {\n        let current = this.head;\n        let currentIndex = 0;\n        while (currentIndex++ < index) {\n          el = current;\n          if (current) {\n            current = current.next;\n          }\n        }\n        if (el) {\n          node.next = current;\n          el.next = node;\n        }\n      }\n      this.size++;\n      this.length++;\n    }\n  }\n  // Удаление элемента по индексу\n  deleteByIndex(index: number) {\n    // Проверяем, что индекс находится в допустимом диапазоне\n    if (index < 0 || index > this.size) {\n      return;\n    }\n    let start = this.head;\n    // Если индекс 0, добавляем новый узел в начало списка\n    if (index === 0) {\n      this.head = this.head ? this.head.next : this.head;\n    } else {\n      let current = null;\n      let currIndex = 0;\n      // Ищем узел с указанным индексом\n      while (currIndex++ < index) {\n        // Запоминаем текущий узел и переходим к следующему, если есть\n        current = start;\n        if (start) {\n          start = start.next;\n        }\n      }\n      // Обрываем связь между предыдущим и удаляемым узлом\n      if (current?.next) {\n        current.next = start?.next ? start.next : null;\n      }\n    }\n    this.size--;\n    this.length--;\n  }\n  // Преобразование списка в массив\n  toArray() {\n    // Инициализация указателя на начало списка\n    let current = this.head;\n    // Создание массива для хранения значений узлов списка\n    const array: T[] = [];\n    // Проход по списку\n    while (current) {\n      // Добавление значения текущего узла\n      array.push(current?.value);\n      // Переход к следующему узлу\n      current = current.next;\n    }\n    return array;\n  }\n  // Получение размера списка\n  getSize() {\n    return this.size;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}